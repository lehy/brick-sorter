{"version":3,"sources":["BrickInferenceSession.tsx","BrickCam.tsx","BrickPredictionDisplay.tsx","BrickPred.tsx","BrickInference.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["BrickInferenceSession","backend","onSessionInitialized","a","console","log","session","onnx","InferenceSession","backendHint","loadModel","React","useEffect","init","BrickCam","onImage","height","webcamRef","useRef","handleData","current","canvas","getCanvas","ctx","getContext","data","getImageData","width","rgb_array","Array","fill","plane","i","j","chan","image","rgb_chw","handleRawData","setTimeout","e","audio","ref","videoConstraints","facingMode","BrickPredictionDisplay","predictions","items","forEach","pred","name","pred_text","proba","value","toFixed","push","TextField","label","dt_filtered","dt_alpha","BrickPred","onPrediction","computeSinglePrediction","output","category","z","best_i","best_logp","length","logp","Math","exp","best_p","reportNetworkOutputs","outputs","dt","preds","Map","o","cat_name","cats","categories","set","t0","performance","now","tensor","Tensor","run","message","includes","t1","processImage","BrickInferencePredBlock","useState","prediction","setPrediction","BrickInference","setImage","usePaperStyles","makeStyles","theme","createStyles","root","display","flexWrap","margin","spacing","padding","App","setSession","classes","className","CssBaseline","Paper","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"67YAwCeA,MAhCf,YAAkI,IAAlGC,EAAiG,EAAjGA,QAASC,EAAwF,EAAxFA,qBAAwF,4CAC/H,4BAAAC,EAAA,6DACEC,QAAQC,IAAR,oBAEIJ,GACFG,QAAQC,IAAR,0CAA+CJ,IAC/CK,EAAU,IAAIC,KAAKC,iBAAiB,CAACC,YAAaR,MAElDG,QAAQC,IAAR,2CACAC,EAAU,IAAIC,KAAKC,kBAGT,eAXd,SAYQF,EAAQI,UADF,gBAXd,OAcEN,QAAQC,IAAI,0BACZD,QAAQC,IAAIC,GACZJ,EAAqBI,GAhBvB,4CAD+H,sBA6B/H,OARAK,IAAMC,WAAU,WACdR,QAAQC,IAAI,wBAtBiH,mCAuB7HQ,KACC,CAACZ,EAASC,IAKN,8B,iBCmCMY,MAlEf,YAA+E,IAA3DC,EAA0D,EAA1DA,QAASC,EAAiD,EAAjDA,OACrBC,EAAYN,IAAMO,OAAe,MAqCvC,SAASC,IAEP,KArCoB,WAEpB,GAAKF,EAAUG,QAAf,CAIA,IACMC,EADiBJ,EAAUG,QACXE,YACtB,GAAKD,EAAL,CAIA,IAAME,EAAMF,EAAOG,WAAW,MAC9B,GAAKD,EAAL,CAUA,IANA,IAAME,EAAOF,EAAIG,aAAa,EAAG,EAAGL,EAAOM,MAAON,EAAOL,QAInDY,EAAYC,MAAMJ,EAAKE,MAAQF,EAAKT,OAAS,GAAGc,KAAK,GACrDC,EAAQN,EAAKE,MAAQF,EAAKT,OACvBgB,EAAI,EAAGA,EAAIP,EAAKT,SAAUgB,EACjC,IAAK,IAAIC,EAAI,EAAGA,EAAIR,EAAKE,QAASM,EAChC,IAAK,IAAIC,EAAO,EAAGA,EAAO,IAAKA,EAC7BN,EAAUG,EAAQG,EAAOT,EAAKE,MAAQK,EAAIC,GAAKR,EAAKA,KAAK,GAAKA,EAAKE,MAAQK,EAAIC,GAAKC,GAAQ,IAKlG,IAAIC,EAAQ,CAACC,QAASR,EAAWD,MAAOF,EAAKE,MAAOX,OAAQS,EAAKT,QACjED,EAAQoB,QAlBN/B,QAAQC,IAAI,0BALZD,QAAQC,IAAI,kBANZD,QAAQC,IAAI,qBAmCZgC,GAEAC,YAAW,kBAAMnB,MAAc,KAC/B,MAAOoB,GACPnC,QAAQC,IAAI,+DAgBhB,OANAM,IAAMC,WANN,WAEEO,MAI+B,IAM1B,cAAC,IAAD,CAAQqB,OAAO,EAAOC,IAAKxB,EAAWyB,iBAJtB,CACrBC,WAAY,eAKd3B,OAAQA,K,QClDK4B,MAff,YAA2E,IAA1CC,EAAyC,EAAzCA,YAC3BC,EAA4B,GAWhC,OAVAD,EAAYE,SAAQ,SAASC,EAAwBC,GACnD,IAAIC,EAEFA,EADEF,EAAKG,MACE,UAAMH,EAAKI,MAAX,cAAmC,IAAbJ,EAAKG,OAAaE,QAAQ,GAAhD,KAEA,UAAML,EAAKI,OAEtBN,EAAMQ,KAAK,cAACC,EAAA,EAAD,CAAsBC,MAAOP,EAAMG,MAAOF,GAA1BD,OAGtB,8BAAMH,K,gBCKXW,EAAc,GACdC,EAAW,GAyFAC,MAtFf,YAEqF,IAFhExB,EAE+D,EAF/DA,MAAO7B,EAEwD,EAFxDA,QAASsD,EAE+C,EAF/CA,aAInC,SAASC,EAAT,GAME,IAL8F,IAD7DC,EAC4D,EAD5DA,OAAQC,EACoD,EADpDA,SAGrCC,EAAI,EACJC,EAAS,EACTC,GAAa,KACRlC,EAAI,EAAGA,EAAI8B,EAAOK,SAAUnC,EAAG,CACtC,IAAIoC,EAAON,EAAO9B,GACdoC,GAAQF,IACVD,EAASjC,EACTkC,EAAYE,GAEdJ,GAAKK,KAAKC,IAAIF,GAEhB,IAAIG,EAAkBF,KAAKC,IAAIJ,GAAaF,EAK5C,MAAO,CAACZ,MAJOW,EAASE,GAICd,MAAOoB,GAGlC,SAASC,EAAqBC,EAAcC,GAG1C,IAHsD,EAGlDC,EAAsB,IAAIC,IAHwB,cAIxCH,GAJwC,IAItD,2BAAuB,CAAC,IAAfI,EAAc,QACjBC,EAAWD,EAAE,GACbE,EAAOC,EAAWF,GAElB9B,EAAOa,EAAwB,CAACC,OADvBe,EAAE,GAAGpD,KACkCsC,SAAUgB,IAC9DJ,EAAMM,IAAIH,EAAU9B,IATgC,8BAWtD2B,EAAMM,IAAI,KAAM,CAAC7B,MAAM,GAAD,OAAIsB,EAAGrB,QAAQ,GAAf,OAAwBF,MAAO,OACrDS,EAAae,GApCmE,4CAuClF,WAA4BxC,GAA5B,qBAAAhC,EAAA,yDACQG,EADR,uBAEIF,QAAQC,IAAI,yBAFhB,iCAKM6E,EAAKC,YAAYC,MACfC,EAAS,IAAI9E,KAAK+E,OAAOnD,EAAMC,QAAS,UAAW,CAAC,EAAG,EAAGD,EAAMnB,OAAQmB,EAAMR,QANtF,kBAYoBrB,EAAQiF,IAAI,CAACF,IAZjC,OAYIZ,EAZJ,4DAeIrE,QAAQC,IAAI,0BACZD,QAAQC,IAAR,MACK,KAAEmF,QAAQC,SAAS,2BAjB5B,oCAqBMC,EAAKP,YAAYC,MAOT,EAEZZ,EAAqBC,EAPrBhB,EAAcC,EAAWD,GAAe,EAAIC,IADnCgC,EAAKR,IAtBhB,2DAvCkF,sBAiFlF,OATAvE,IAAMC,WAAU,WAEVuB,GAAS7B,EA1EmE,oCA2E9EqF,CAAaxD,GAEb/B,QAAQC,IAAI,qCAEb,CAAC8B,EAAO7B,IAEJ,8BCrGT,SAASsF,EAAT,GAEkE,IAFhCzD,EAE+B,EAF/BA,MAAO7B,EAEwB,EAFxBA,QAEwB,EAC7BK,IAAMkF,SAAsB,IAAIjB,KADH,mBAC1DkB,EAD0D,KAC9CC,EAD8C,KAG/D,OAAQ,qCACA,cAAC,EAAD,CAAW5D,MAAOA,EAClByB,aAAcmC,EAAezF,QAASA,IACtC,cAAC,EAAD,CAAwBuC,YAAaiD,OAahCE,MATf,YAAwE,IAA/C1F,EAA8C,EAA9CA,QAA8C,EAC7CK,IAAMkF,SAA4B,MADW,mBAChE1D,EADgE,KACzD8D,EADyD,KAGrE,OAAQ,qCACA,cAAC,EAAD,CAAUlF,QAASkF,EAAUjF,OAAQ,MACrC,cAAC4E,EAAD,CAAyBzD,MAAOA,EAAO7B,QAASA,Q,gBCXpD4F,EAAiBC,aAAW,SAACC,GAAD,OACLC,YAAa,CACXC,KAAM,CACJC,QAAS,OACTC,SAAU,OACV,QAAS,CACPC,OAAQL,EAAMM,QAAQ,GACtBC,QAASP,EAAMM,QAAQ,GACvB/E,MAAOyE,EAAMM,QAAQ,WA8BzCE,MAvBf,WAAgB,IAAD,EACejG,IAAMkF,SAAkC,MADvD,mBACRvF,EADQ,KACCuG,EADD,OAGelG,IAAMkF,SAAS,SAH9B,mBAGR5F,EAHQ,KAKP6G,GALO,KAKGZ,KAGhB,OACI,sBAAKa,UAAU,MAAf,UACA,cAACC,EAAA,EAAD,IACA,cAAC,EAAD,CAAuB/G,QAASA,EAASC,qBAAsB2G,IAE/D,qBAAKE,UAAWD,EAAQR,KAAxB,SACA,cAACW,EAAA,EAAD,UACA,cAAC,EAAD,CAAgB3G,QAASA,YC7BhB4G,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,EAAgB9G,QAAQC,O","file":"static/js/main.0c7da44f.chunk.js","sourcesContent":["import \"onnxjs\";\nimport React from 'react';\nimport { InferenceSession } from \"onnxjs\";\n\ntype OnSessionInitialized = (session:InferenceSession) => void;\n\n// var initialized = false;\n\nfunction BrickInferenceSession({backend, onSessionInitialized} : {backend?: string, onSessionInitialized: OnSessionInitialized}) {\n  async function init() {\n    console.log(`creating session`);\n    var session;\n    if (backend) {\n      console.log(`- creating session with backend ${backend}`);\n      session = new onnx.InferenceSession({backendHint: backend});\n    } else {\n      console.log(`- creating session with no backend hint`);\n      session = new onnx.InferenceSession();\n    };\n    \n    const url = \"./model.onnx\";\n    await session.loadModel(url);\n\n    console.log(\"session is initialized\");\n    console.log(session);\n    onSessionInitialized(session);\n  };\n\n  // if (!initialized) {\n  React.useEffect(() => {\n    console.log(\"initializing session\");\n    init();\n  }, [backend, onSessionInitialized]);\n  // initialized = true;\n  // } else {\n  // console.log(\"attempt to reinitialize session!\");\n  // }\n  return <></>;\n};\n\nexport default BrickInferenceSession;\n","import React from 'react';\nimport Webcam from \"react-webcam\";\nimport BrickImage from \"./BrickImage\";\n\ntype OnImage = (image: BrickImage) => void;\n\nfunction BrickCam({ onImage, height }: { onImage: OnImage; height: number; }) {\n  const webcamRef = React.useRef<Webcam>(null);\n  \n  const handleRawData = () => {\n    // console.log(\"data is available!\");\n    if (!webcamRef.current) {\n      console.log(\"no webcam ref yet\");\n      return;\n    }\n    const webcam: Webcam = webcamRef.current;\n    const canvas = webcam.getCanvas(); // { width: width, height: height });\n    if (!canvas) {\n      console.log(\"no canvas\");\n      return;\n    }\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      console.log(\"no canvas context\");\n      return;\n    }\n    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    // data is a single dimensional array of RGBA values, given by\n    // rows (C-style).\n    // Convert to a channels x width x height single-dim array.\n    const rgb_array = Array(data.width * data.height * 3).fill(0);\n    const plane = data.width * data.height;\n    for (var i = 0; i < data.height; ++i) {\n      for (var j = 0; j < data.width; ++j) {\n        for (var chan = 0; chan < 3; ++chan) {\n          rgb_array[plane * chan + data.width * i + j] = data.data[4 * (data.width * i + j) + chan] / 255.;\n        }\n      }\n    }\n    // console.log(\"handleRawData: calling onImage()\");\n    let image = {rgb_chw: rgb_array, width: data.width, height: data.height};\n    onImage(image);\n  };\n  \n  function handleData() {\n    // console.log(\"handleData(): calling handleRawData()\");\n    try {\n      handleRawData();\n      // console.log(\"handleRawData finished, scheduling one for later\")\n      setTimeout(() => handleData(), 200);\n    } catch (e) {\n      console.log(\"handleDrawData raised an exception, not scheduling anymore\");\n    }\n  };\n\n  function startHandleData() {\n    // console.log(\"------------- start handleData()\");\n    handleData();\n  }\n  \n  // React.useCallback(handleData, [onImage, webcamRef, handleData, handleRawData]);\n  React.useEffect(startHandleData, []);\n\n  let videoConstraints = {\n    facingMode: \"environment\"\n  };\n  \n  return <Webcam audio={false} ref={webcamRef} videoConstraints={videoConstraints}\n  //onUserMedia={handleData}\n  height={height} / >;\n}\n\nexport default BrickCam;\n","import React from 'react';\nimport TextField from \"@material-ui/core/TextField\";\nimport {Predictions, SinglePrediction} from \"./BrickPred\";\n\nfunction BrickPredictionDisplay({predictions}: {predictions:Predictions}) {\n  var items : React.ReactNode[] = [];\n  predictions.forEach(function(pred: SinglePrediction, name : string) {\n    var pred_text;\n    if (pred.proba) {\n      pred_text = `${pred.value} (${(pred.proba * 100).toFixed(0)})`;\n    } else {\n      pred_text = `${pred.value}`;\n    }\n    items.push(<TextField key={name} label={name} value={pred_text} />);\n  });\n\n  return <div>{items}</div>;\n}\n\nexport default BrickPredictionDisplay;\n\n","import \"onnxjs\";\nimport { InferenceSession } from \"onnxjs\";\nimport React from \"react\";\nimport categories from \"./categories.json\";\nimport BrickImage from \"./BrickImage\";\n\nexport interface SinglePrediction {\n  value: string;\n  proba: number | null;\n};\n\n// export interface Predictions {\n//   part: SinglePrediction;\n//   color: SinglePrediction;\n//   category: SinglePrediction;\n//   size: SinglePrediction;\n// };\nexport type Predictions = Map<string, SinglePrediction>;\n\nexport type OnPrediction = (predictions : Predictions) => void;\n\nvar dt_filtered = 50;\nvar dt_alpha = 0.9;\nvar num_step = 0;\n\nfunction BrickPred({ image, session, onPrediction }:\n                  { image: BrickImage | null,\n                    session: InferenceSession | null, onPrediction: OnPrediction }) {\n\n  function computeSinglePrediction({ output, category }:\n                                   { output: number[]; category: string[]; }) : SinglePrediction {\n    // console.log(`${cat}: ${output} ${category}`)\n    var z = 0.;\n    var best_i = 0;\n    var best_logp = -1e12;\n    for (let i = 0; i < output.length; ++i) {\n      let logp = output[i];\n      if (logp >= best_logp) {\n        best_i = i;\n        best_logp = logp;\n      }\n      z += Math.exp(logp);\n    }\n    let best_p : number = Math.exp(best_logp) / z;\n    let best_cat = category[best_i];\n    // let p_percent = (best_p * 100).toFixed(0);\n    // console.log(`${cat}: ${best_cat} (${best_p})`);\n    // return `${best_cat} (${p_percent}%)`;\n    return {value: best_cat, proba: best_p};\n  };\n\n  function reportNetworkOutputs(outputs: any, dt: number) {\n    // console.log(outputs);\n    // var outputs_merged = [];\n    let preds : Predictions = new Map<string, SinglePrediction>();\n    for (let o of outputs) {\n      let cat_name = o[0];\n      let cats = categories[cat_name as keyof typeof categories]; // arf\n      let logits = o[1].data;\n      let pred = computeSinglePrediction({output: logits, category: cats});\n      preds.set(cat_name, pred);\n    }\n    preds.set(\"dt\", {value:`${dt.toFixed(0)} ms`, proba: null});\n    onPrediction(preds);\n  };\n  \n  async function processImage(image : BrickImage) {\n    if (! session) {\n      console.log(\"BrickPred: no session\");\n      return;\n    }\n    let t0 = performance.now();\n    const tensor = new onnx.Tensor(image.rgb_chw, 'float32', [1, 3, image.height, image.width]);\n    // if (num_step < 5) {\n    //   console.log(tensor);\n    // }\n    var outputs;\n    try {\n      outputs = await session.run([tensor]);\n      // console.log(output);\n    } catch (e) {\n      console.log(\"error running session:\");\n      console.log(e);\n      if (!e.message.includes(\"session not initialized\")) {\n        throw e;\n      }\n    }\n    let t1 = performance.now();\n    let dt = t1 - t0;\n    dt_filtered = dt_alpha * dt_filtered + (1 - dt_alpha) * dt;\n    // let dtfs = dt_filtered.toFixed(0);\n    // if ((num_step % 10 * 60) === 0) {\n    //   console.log(`inference: ${dtfs} ms`);\n    // }\n    num_step += 1;\n\n    reportNetworkOutputs(outputs, dt_filtered);\n  }\n\n  React.useEffect(() => {\n    // console.log(\"computing pred\")\n    if (image && session) {\n      processImage(image);\n    } else {\n      console.log(\"no image or no session: no pred\");\n    }\n  }, [image, session]);\n\n  return <></>;\n}\n\nexport default BrickPred;\n","import React from \"react\";\nimport BrickCam from \"./BrickCam\";\nimport BrickPredictionDisplay from \"./BrickPredictionDisplay\";\nimport BrickPred, { Predictions } from \"./BrickPred\";\nimport { InferenceSession } from 'onnxjs';\nimport BrickImage from \"./BrickImage\";\n\nfunction BrickInferencePredBlock({image, session}:\n                                {image:BrickImage|null,\n                                 session:InferenceSession|null}) {\n  let [prediction, setPrediction] = React.useState<Predictions>(new Map());\n\n  return (<>\n          <BrickPred image={image}\n          onPrediction={setPrediction} session={session} />\n          <BrickPredictionDisplay predictions={prediction} />\n          </>);\n}\n\nfunction BrickInference({session}:{session : InferenceSession | null}) {\n  let [image, setImage] = React.useState<BrickImage | null>(null);\n\n  return (<>\n          <BrickCam onImage={setImage} height={224} />\n          <BrickInferencePredBlock image={image} session={session} />\n          </>);\n}\n\nexport default BrickInference;\n","import React from 'react';\n// import logo from './logo.svg';\nimport './App.css';\n// import Webcam from \"react-webcam\";\nimport \"onnxjs\";\nimport Paper from \"@material-ui/core/Paper\";\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport BrickInferenceSession from \"./BrickInferenceSession\";\nimport BrickInference from \"./BrickInference\";\nimport BrickBackendSelector from \"./BrickBackendSelector\";\nimport { Theme, createStyles, makeStyles } from '@material-ui/core/styles';\nimport { InferenceSession } from 'onnxjs';\n\nconst usePaperStyles = makeStyles((theme: Theme) =>\n                             createStyles({\n                               root: {\n                                 display: 'flex',\n                                 flexWrap: 'wrap',\n                                 '& > *': {\n                                   margin: theme.spacing(1),\n                                   padding: theme.spacing(1),\n                                   width: theme.spacing(48),\n                                   // height: theme.spacing(48)\n                                 },\n                               },\n                             }),\n                            );\n\nfunction App() {\n  let [session, setSession] = React.useState<InferenceSession | null>(null);\n  // let backend = undefined; //\"webgl\";\n  let [backend, setBackend] = React.useState(\"webgl\");\n  \n  const classes = usePaperStyles();\n\n  // <BrickBackendSelector backend={backend} onBackendChanged={setBackend} />\n  return (\n      <div className=\"App\">\n      <CssBaseline />\n      <BrickInferenceSession backend={backend} onSessionInitialized={setSession} />\n      \n      <div className={classes.root}>\n      <Paper>\n      <BrickInference session={session} />\n      </Paper>\n      </div>\n      \n      </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals(console.log);\n"],"sourceRoot":""}